#
# Only for python3 and docker
#
version: 0.2

env:
  shell: bash
  variables:
    SHELL: /bin/bash
    AWS_DEFAULT_REGION: eu-central-1
    SERVICE_NAME: "mf-chsdi3"
    DOCKER_REGISTRY: "974517877189.dkr.ecr.eu-central-1.amazonaws.com"
    USER: "aws_code_build"
    CI_QUIET: 1
    SYSTEM_PYTHON_CMD: python3
    # DB connection variable are used by the buildspec to verify DB connectivity therefore
    # they need to be defined outside of .env.ci
    # TODO once the migration is done use pg-geodata-replica.bgdi.ch (DB in Frankfurt)
    DBHOST: pg.bgdi.ch
    DBPORT: 5432
    # DBSTAGING and GEODATA_STAGING values depends on the PR therefore they are set here and not
    # in the .env.ci file
    DBSTAGING: dev
    GEODATA_STAGING: test
    ENV_FILE: .env.ci
  parameter-store:
    OPENTRANS_API_KEY: "/opentrans_api/key"
    PGUSER: "/postgresql/pguser"
    PGPASSWORD: "/postgresql/pgpassword"

phases:
  install:
    runtime-versions:
      python: 3.7
    commands:
      - echo "Installing kubectl"
      - curl -o kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.22.6/2022-03-09/bin/linux/amd64/kubectl
      - chmod +x ./kubectl
      - mkdir -p $HOME/bin && cp ./kubectl $HOME/bin/kubectl && export PATH=$PATH:$HOME/bin
      - kubectl version --short --client
      - echo "Configure AWS profile swisstopo-bgdi-dev"
      - sts=$(aws sts assume-role --role-arn "arn:aws:iam::839910802816:role/kubernetes-codebuild-dev" --role-session-name "swisstopo-bgdi-dev")
      - aws configure set aws_access_key_id $(echo $sts | jq -r '.Credentials''.AccessKeyId') --profile swisstopo-bgdi-dev
      - aws configure set aws_secret_access_key $(echo $sts | jq -r '.Credentials''.SecretAccessKey') --profile swisstopo-bgdi-dev
      - aws configure set aws_session_token $(echo $sts | jq -r '.Credentials''.SessionToken') --profile swisstopo-bgdi-dev
      - echo "Login to AWS ECR docker registry"
      - aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${DOCKER_REGISTRY}

  pre_build:
    commands:
      - echo "=========== Configuring stuff ====="
      - export PULL_REQUEST=${CODEBUILD_WEBHOOK_TRIGGER#pr/*}
      - |-
        if [[ -n "${CODEBUILD_WEBHOOK_HEAD_REF}" ]]; then
          export GIT_BRANCH="${CODEBUILD_WEBHOOK_HEAD_REF#refs/heads/}"
        else
          # NOTE: For manual build trigger, CODEBUILD_WEBHOOK_HEAD_REF is not set therefore get
          # the branch name from git command. This is a bit hacky but did not find any other solution
          echo CODEBUILD_RESOLVED_SOURCE_VERSION=${CODEBUILD_RESOLVED_SOURCE_VERSION}
          export GIT_BRANCH=$(git describe --all | awk '{gsub("remotes/origin/|origin/|heads/|refs/heads/", ""); print $1}')
        fi
      - export GIT_BASE_BRANCH="${CODEBUILD_WEBHOOK_BASE_REF#refs/heads/}"
      - export GIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - export GIT_TAG="$(git describe --tags --dirty || echo 'unknown')"
      - export GIT_DIRTY="$(git status --porcelain)"
      - |
        if [[ "${GIT_TAG}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}-rc[0-9]+[[:alnum:]-]*$$ ]]; then
          export APP_VERSION="${GIT_TAG}"
        else
          export APP_VERSION="0000-00-00-rc0-${GIT_HASH_SHORT}"
        fi
      - |-
        if [ "${GIT_TAG}" = "unknown"  ] ; then
          DOCKER_IMG_TAG="${DOCKER_REGISTRY}/${SERVICE_NAME}:${GIT_BRANCH//\//_}.${GIT_HASH}"
        else
          DOCKER_IMG_TAG="${DOCKER_REGISTRY}/${SERVICE_NAME}:${GIT_TAG}"
        fi
      - export DOCKER_IMG_TAG=${DOCKER_IMG_TAG}
      - export DOCKER_IMG_TAG_LATEST="${DOCKER_REGISTRY}/${SERVICE_NAME}:${GIT_BRANCH//\//_}.latest"
      - echo "=========== Data Staging =========="
      # The data staging for the tests depends on the BASE branch and on the HEAD branch.
      # For personal PR to `master` (hotfix or general non milestone dependend work) we need
      # to use the PROD data staging for the tests otherwise they might fail.
      # On the otherhand for PR to merge `develop-*` to `master` (on deploy day) we still need to
      # use DEV data staging because the PROD data staging might not be yet fully ready !
      # CI is also triggered on a push event, in this case the CODEBUILD_WEBHOOK_BASE_REF is empty
      # and CODEBUILD_WEBHOOK_HEAD_REF is set to the branch on which the push event occurs. In
      # this case we use the last commit message to determine if it is a push event triggered by
      # a PR merge and to determine the base branch from the commit title which is then in the
      # following form: `Merge pull request #XXXX from ORGANIZATION/BRANCH`
      - git --no-pager log -1 --oneline
      - export MERGED_FROM=$(git --no-pager log -1 --format=%s | awk '/Merge pull request [#][0-9]+ from / {print $6}')
      - |
        if [[ "${GIT_BASE_BRANCH}" == master ]] && \
           [[ "${GIT_BRANCH}" != develop* ]];
        then
          # PR to merge personal branch (feature or bug) into master
          export DBSTAGING=prod
          export GEODATA_STAGING=prod
        elif [[ "${GIT_BRANCH}" == master ]] && \
             [[ "${MERGED_FROM}" != geoadmin/develop* ]];
        then
          # Push event triggered either by a PR merge on master (except for PR to merge develop* into master)
          # or by a push on the master branch.
          export DBSTAGING=prod
          export GEODATA_STAGING=prod
        fi
      - echo "=========== VERSIONS =============="
      - aws --version
      - python3 --version
      - node --version
      - bash --version
      - echo "=========== VARIABLES ============="
      - echo CODEBUILD_INITIATOR=${CODEBUILD_INITIATOR}
      - echo CODEBUILD_RESOLVED_SOURCE_VERSION=${CODEBUILD_RESOLVED_SOURCE_VERSION}
      - echo CODEBUILD_SOURCE_VERSION=${CODEBUILD_SOURCE_VERSION}
      - echo CODEBUILD_WEBHOOK_EVENT=${CODEBUILD_WEBHOOK_EVENT}
      - echo CODEBUILD_WEBHOOK_ACTOR_ACCOUNT_ID=${CODEBUILD_WEBHOOK_ACTOR_ACCOUNT_ID}
      - echo CODEBUILD_WEBHOOK_BASE_REF=${CODEBUILD_WEBHOOK_BASE_REF}
      - echo CODEBUILD_WEBHOOK_HEAD_REF=${CODEBUILD_WEBHOOK_HEAD_REF=}
      - echo CODEBUILD_WEBHOOK_TRIGGER=${CODEBUILD_WEBHOOK_TRIGGER}
      - echo CODEBUILD_WEBHOOK_MERGE_COMMIT=${CODEBUILD_WEBHOOK_MERGE_COMMIT}
      - echo CODEBUILD_WEBHOOK_PREV_COMMIT=${CODEBUILD_WEBHOOK_PREV_COMMIT}
      - echo CODEBUILD_BUILD_ID=${CODEBUILD_BUILD_ID}
      - echo CODEBUILD_SOURCE_REPO_URL=${CODEBUILD_SOURCE_REPO_URL}
      - echo MERGED_FROM=${MERGED_FROM}
      - echo PULL_REQUEST=${PULL_REQUEST}
      - echo GIT_BRANCH=${GIT_BRANCH}
      - echo GIT_HASH=${GIT_HASH}
      - echo GIT_TAG=${GIT_TAG}
      - echo GIT_DIRTY=${GIT_DIRTY}
      - echo DOCKER_IMG_TAG=${DOCKER_IMG_TAG}
      - echo DOCKER_IMG_TAG_LATEST=${DOCKER_IMG_TAG_LATEST}
      - echo DBSTAGING=${DBSTAGING}
      - echo GEODATA_STAGING=${GEODATA_STAGING}
      - echo BASH=${BASH}
      - echo CURRENT_DIRECTORY=$(pwd)
      - echo USE_PYTHON3=${USE_PYTHON3}
      - echo "=========== POSGRESQL ============="
      - python ./scripts/pg_ready.py
      - echo "host=$(hostname -I)"
      - echo "=========== PREPARE ==============="
      - make cleanall setup
      - echo "=========== LINTING ==============="
      - make lint

  build:
    commands:
      - echo "=========== BUILD ================="
      - echo Build started on $(date)
      - make build
      - echo "=========== DOCKER BUILD =========="
      - >
        docker build
        --build-arg GIT_HASH="${GIT_HASH}"
        --build-arg GIT_BRANCH="${GIT_BRANCH}"
        --build-arg GIT_DIRTY="${GIT_DIRTY}"
        --build-arg GIT_TAG="${GIT_TAG}"
        --build-arg AUTHOR="CI"
        --build-arg VERSION="${APP_VERSION}"
        -t "${DOCKER_IMG_TAG}" -t "${DOCKER_IMG_TAG_LATEST}" .
      - echo Build completed on $(date)

  post_build:
    commands:
      - echo "=========== Running tests ========="
      - |
        if [[ -z "${GIT_BASE_BRANCH}" ]];
        then
          echo "!!!!!!!! WARNING: Could not find the git BASE branch, might be due to manual build !!!!!!!"
          echo "!!!!!!!! WARNING: STAGING for testing might be incorrect !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        fi
      - make unittest-ci
      # Only pushes images to ECR for PR that have been merged, this means that the event triggering
      # the CI is a git push and not a PR event. In this case the GIT_BRANCH variable as the name
      # of the branch which got the push event.
      - |
        if [[ "${GIT_BRANCH}" == master ]] || [[ "${GIT_BRANCH}" == develop-* ]]; then
          echo "=========== Pushing image ========="
          echo "Push image ${DOCKER_IMG_TAG}"
          docker push ${DOCKER_IMG_TAG}
          echo "Push latest image ${DOCKER_IMG_TAG_LATEST}"
          docker push ${DOCKER_IMG_TAG_LATEST}
        fi
      - echo "Done"
      - |
        if [[ "${GIT_BRANCH}" == develop-* ]]; then
          echo "=========== Deploy on DEV ======"
          echo "Setup kubectl with AWS profile"
          aws --profile swisstopo-bgdi-dev --region eu-central-1 \
              eks update-kubeconfig \
                --name dev \
                --alias swisstopo-bgdi-dev \
                --role-arn "arn:aws:iam::839910802816:role/kubernetes-codebuild-dev"
          kubectl config use-context swisstopo-bgdi-dev
          echo "Rollout restart service on DEV"
          kubectl -n mf-chsdi3 rollout restart deployment
        fi


reports:
  reportGroupJunit:
    files:
      - "junit-reports/**/*"
    file-format: JunitXml
